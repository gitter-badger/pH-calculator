sem <- sd / sqrt(length(df))
data.frame(mean, sd, sem)
}
# Calibrate
source(paste(directory, "calibrate/calibrate.R", sep=""))
# Read files in a for loop
setwd(paste(directory, "measurements_CELLASIC", sep=""))
# FITC/FITC
df_ff = NULL
for(i in 1:6){
#FITC/FITC
df_ff_temp = read.delim(paste("Results_", name, "_0", i, "_ff", ".txt", sep=""))
time = df_ff_temp$X*timeRes-10
replicate = rep(i, nrow(df_ff_temp))
channel = rep("ff", nrow(df_ff_temp))
df_ff_temp = cbind(df_ff_temp, time, replicate, channel)
df_ff = rbind(df_ff, df_ff_temp)
}
# DAPI/FITC
df_df = NULL
for(i in 1:6){
#FITC/FITC
df_df_temp = read.delim(paste("Results_", name, "_0", i, "_df", ".txt", sep=""))
time = df_ff_temp$X*timeRes-10
replicate = rep(i, nrow(df_df_temp))
channel = rep("df", nrow(df_df_temp))
df_df_temp = cbind(df_df_temp, time, replicate, channel)
df_df = rbind(df_df, df_df_temp)
}
# Ratios
df_ratios = data.frame(cbind(df_ff$time, df_ff$replicate, df_df$Mean1/df_ff$Mean1))
colnames(df_ratios) = c("time", "replicate", "ratio")
# Normalize
#norm_ratios = df_ratios$ratio/mean_ratio_70
# Calc pH
pH = calc_pH(df_ratios$ratio, best_fit)
# Final dataframe
df_pH = cbind(df_ratios, pH)
# Get stats over time
df_final = ddply(df_pH, .(time), stats)
# Plot
p = ggplot(df_final, aes(x=time, y=mean))
p = p + geom_line(size=1, colour="red")
p = p + geom_point(size=3)
p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1, width=4)
p = p + scale_x_continuous(limits=c(0, 420), breaks=seq(0, 420, 60))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(title=name, x="time [min]", y="pH")
p = p + theme_bw(base_size=24)
p
# Save plot
setwd(paste(directory, "plots", sep=""))
ggsave(p, file=paste(name, ".pdf", sep=""), width=9, height=6)
#### Measure pH with pHluorin2 ###
##
## Timeseries in CellASICS chamber##
##
####
# Set working directory -------------------------------------------------------
rm(list=ls()) # clean up
directory = "~/Git/pH-calculator/"
setwd(directory)
# Load required packages ------------------------------------------------------
library("ggplot2")
library("plyr")
library("tcltk")
# Set parameters --------------------------------------------------------------
# Please adjust all of the following parameters
name = "SD-glu"
#dirOutput = "/Users/munder/PhD/pH-measurements/"
folderOutput = "plots/" # give name of output folder here
timeRes = 10 # in minutes
# Define functions ------------------------------------------------------------
calc_pH = function(emission_ratio, model){
coefs = coef(model)
#y = a + bx + cx^2 + bx^3 + ax^4
calculated_pH = coefs[1] + (coefs[2] * emission_ratio) + (coefs[3] * emission_ratio^2) + (coefs[4] * emission_ratio^3) + (coefs[5] * emission_ratio^4)
return(calculated_pH)
}
stats = function(df){
mean<- mean(df$pH)
sd <- sd(df$pH)
sem <- sd / sqrt(length(df))
data.frame(mean, sd, sem)
}
# Calibrate
source(paste(directory, "calibrate/calibrate.R", sep=""))
# Read files in a for loop
setwd(paste(directory, "measurements_CELLASIC", sep=""))
# FITC/FITC
df_ff = NULL
for(i in 1:6){
#FITC/FITC
df_ff_temp = read.delim(paste("Results_", name, "_0", i, "_ff", ".txt", sep=""))
time = df_ff_temp$X*timeRes-10
replicate = rep(i, nrow(df_ff_temp))
channel = rep("ff", nrow(df_ff_temp))
df_ff_temp = cbind(df_ff_temp, time, replicate, channel)
df_ff = rbind(df_ff, df_ff_temp)
}
# DAPI/FITC
df_df = NULL
for(i in 1:6){
#FITC/FITC
df_df_temp = read.delim(paste("Results_", name, "_0", i, "_df", ".txt", sep=""))
time = df_ff_temp$X*timeRes-10
replicate = rep(i, nrow(df_df_temp))
channel = rep("df", nrow(df_df_temp))
df_df_temp = cbind(df_df_temp, time, replicate, channel)
df_df = rbind(df_df, df_df_temp)
}
# Ratios
df_ratios = data.frame(cbind(df_ff$time, df_ff$replicate, df_df$Mean1/df_ff$Mean1))
colnames(df_ratios) = c("time", "replicate", "ratio")
# Normalize
#norm_ratios = df_ratios$ratio/mean_ratio_70
# Calc pH
pH = calc_pH(df_ratios$ratio, best_fit)
# Final dataframe
df_pH = cbind(df_ratios, pH)
# Get stats over time
df_final = ddply(df_pH, .(time), stats)
# Plot
p = ggplot(df_final, aes(x=time, y=mean))
p = p + geom_line(size=1, colour="red")
p = p + geom_point(size=3)
p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1, width=4)
p = p + scale_x_continuous(limits=c(0, 420), breaks=seq(0, 420, 60))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(title=name, x="time [min]", y="pH")
p = p + theme_bw(base_size=24)
p
# Save plot
setwd(paste(directory, "plots", sep=""))
ggsave(p, file=paste(name, ".pdf", sep=""), width=9, height=6)
#### Measure pH with pHluorin2 ###
##
## Timeseries in CellASICS chamber##
##
####
# Set working directory -------------------------------------------------------
rm(list=ls()) # clean up
directory = "~/Git/pH-calculator/"
setwd(directory)
# Load required packages ------------------------------------------------------
library("ggplot2")
library("plyr")
#library("tcltk")
# Set parameters --------------------------------------------------------------
# Please adjust all of the following parameters
name = "UnitB"
#dirOutput = "/Users/munder/PhD/pH-measurements/"
folderOutput = "plots/" # give name of output folder here
timeRes = 5 # in minutes
# Define functions ------------------------------------------------------------
calc_pH = function(emission_ratio, model){
coefs = coef(model)
#y = a + bx + cx^2 + bx^3 + ax^4
calculated_pH = coefs[1] + (coefs[2] * emission_ratio) + (coefs[3] * emission_ratio^2) + (coefs[4] * emission_ratio^3) + (coefs[5] * emission_ratio^4)
return(calculated_pH)
}
stats = function(df){
mean<- mean(df$pH)
sd <- sd(df$pH)
sem <- sd / sqrt(length(df))
data.frame(mean, sd, sem)
}
# Calibrate
source(paste(directory, "calibrate/calibrate.R", sep=""))
# Read files in a for loop
setwd(paste(directory, "measurements_CELLASIC", sep=""))
# FITC/FITC
df_ff = NULL
for(i in 1:6){
#FITC/FITC
df_ff_temp = read.delim(paste("Results_", name, "_0", i, "_ff", ".txt", sep=""))
time = df_ff_temp$X*timeRes-10
replicate = rep(i, nrow(df_ff_temp))
channel = rep("ff", nrow(df_ff_temp))
df_ff_temp = cbind(df_ff_temp, time, replicate, channel)
df_ff = rbind(df_ff, df_ff_temp)
}
# DAPI/FITC
df_df = NULL
for(i in 1:6){
#FITC/FITC
df_df_temp = read.delim(paste("Results_", name, "_0", i, "_df", ".txt", sep=""))
time = df_ff_temp$X*timeRes-10
replicate = rep(i, nrow(df_df_temp))
channel = rep("df", nrow(df_df_temp))
df_df_temp = cbind(df_df_temp, time, replicate, channel)
df_df = rbind(df_df, df_df_temp)
}
# Ratios
df_ratios = data.frame(cbind(df_ff$time, df_ff$replicate, df_df$Mean1/df_ff$Mean1))
colnames(df_ratios) = c("time", "replicate", "ratio")
# Normalize
#norm_ratios = df_ratios$ratio/mean_ratio_70
# Calc pH
pH = calc_pH(df_ratios$ratio, best_fit)
# Final dataframe
df_pH = cbind(df_ratios, pH)
# Get stats over time
df_final = ddply(df_pH, .(time), stats)
# Plot
p = ggplot(df_final, aes(x=time, y=mean))
p = p + geom_line(size=1, colour="red")
p = p + geom_point(size=3)
p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1, width=4)
#p = p + scale_x_continuous(limits=c(0, 420), breaks=seq(0, 420, 60))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(title=name, x="time [min]", y="pH")
p = p + theme_bw(base_size=24)
p
# Save plot
setwd(paste(directory, "plots", sep=""))
ggsave(p, file=paste(name, ".pdf", sep=""), width=9, height=6)
rm(list=ls()) # clean up
library("ggplot2")
library("plyr")
library("tcltk2")
library("gdata")
input_dir_calibration = tk_choose.dir(caption=("Select input directory containing calibration data."))
setwd(input_dir_calibration)
pH_values = c(4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0)
list_files = list.files(pattern = '.txt')
list_dataframes = llply(list_files, read.delim)
list_norm_ratios = NULL
for(i in seq(2, length(list_dataframes), 2)){
# Area should always normalize to 1! Good control! Just skip the [3] indexing
# normalize to tritc/tritc channel
#norm_ratio = (list_dataframes[[i-2]][3] / list_dataframes[[i]][3]) / (list_dataframes[[i-1]][3] / list_dataframes[[i]][3])
norm_ratio = list_dataframes[[i-1]][3]  / list_dataframes[[i]][3]
list_norm_ratios = append(list_norm_ratios, norm_ratio)
rm(i, norm_ratio)
}
list_norm_ratios = NULL
for(i in seq(2, length(list_dataframes), 2)){
# Area should always normalize to 1! Good control! Just skip the [3] indexing
# normalize to tritc/tritc channel
#norm_ratio = (list_dataframes[[i-2]][3] / list_dataframes[[i]][3]) / (list_dataframes[[i-1]][3] / list_dataframes[[i]][3])
norm_ratio = list_dataframes[[i-1]] / list_dataframes[[i]]
list_norm_ratios = append(list_norm_ratios, norm_ratio)
rm(i, norm_ratio)
}
list_norm_ratios = NULL
for(i in seq(2, length(list_dataframes), 2)){
# Area should always normalize to 1! Good control! Just skip the [3] indexing
# normalize to tritc/tritc channel
#norm_ratio = (list_dataframes[[i-2]][3] / list_dataframes[[i]][3]) / (list_dataframes[[i-1]][3] / list_dataframes[[i]][3])
norm_ratio = list_dataframes[[i-1]][3]  / list_dataframes[[i]][3]
list_norm_ratios = append(list_norm_ratios, norm_ratio)
rm(i, norm_ratio)
}
df_stats = NULL
for(j in seq(6, length(list_norm_ratios), 6)){
pH = pH_values[j/6]
mean_ratio = mean(unlist(list_norm_ratios[(j-5):j]))
sd_ratio = sd(unlist(list_norm_ratios[(j-5):j]))
sem_ratio = sd_ratio / sqrt(length(unlist(list_norm_ratios[(j-5):j])))
df_stats_temp = data.frame(pH, mean_ratio, sd_ratio, sem_ratio)
df_stats = rbind(df_stats, df_stats_temp)
rm(j, mean_ratio, sd_ratio, sem_ratio, pH)
}
# curve fitting
p = ggplot(df_stats, aes(x=pH, y=mean_ratio))
p = p + geom_point()
p
# what's the "best" fit?
x = df_stats$pH
y = df_stats$mean_ratio
plot(x,y,pch=19)
#fit first degree polynomial equation:
fit  <- lm(y~x)
#second degree
fit2 <- lm(y~poly(x,2,raw=TRUE))
#third degree
fit3 <- lm(y~poly(x,3,raw=TRUE))
#fourth degree
fit4 <- lm(y~poly(x,4,raw=TRUE))
#generate range of 100 numbers between highers and lowest dataframe$mean
xx <- seq(min(x), max(x), length=1000)
plot(x,y,pch=19,ylim=c(4.8, 8.2))
lines(xx, predict(fit, data.frame(x=xx)), col="red")
lines(xx, predict(fit2, data.frame(x=xx)), col="green")
lines(xx, predict(fit3, data.frame(x=xx)), col="blue")
lines(xx, predict(fit4, data.frame(x=xx)), col="purple") # seems to be "best" here
best_fit = lm(y~poly(x,4,raw=TRUE))
lines(xx, predict(fit4, data.frame(x=xx)), col="purple") # seems to be "best" here
#fit first degree polynomial equation:
fit  <- lm(y~x)
#second degree
fit2 <- lm(y~poly(x,2,raw=TRUE))
#third degree
fit3 <- lm(y~poly(x,3,raw=TRUE))
#fourth degree
fit4 <- lm(y~poly(x,4,raw=TRUE))
#generate range of 100 numbers between highers and lowest dataframe$mean
xx <- seq(min(x), max(x), length=1000)
plot(x,y,pch=19,ylim=c(4.8, 8.2))
lines(xx, predict(fit, data.frame(x=xx)), col="red")
lines(xx, predict(fit2, data.frame(x=xx)), col="green")
lines(xx, predict(fit3, data.frame(x=xx)), col="blue")
lines(xx, predict(fit4, data.frame(x=xx)), col="purple") # seems to be "best" here
plot(x,y,pch=19)
#fit first degree polynomial equation:
fit  <- lm(y~x)
#second degree
fit2 <- lm(y~poly(x,2,raw=TRUE))
#third degree
fit3 <- lm(y~poly(x,3,raw=TRUE))
#fourth degree
fit4 <- lm(y~poly(x,4,raw=TRUE))
#generate range of 100 numbers between highers and lowest dataframe$mean
xx <- seq(min(x), max(x), length=1000)
plot(x,y,pch=19,ylim=c(4.8, 8.2))
lines(xx, predict(fit, data.frame(x=xx)), col="red")
lines(xx, predict(fit2, data.frame(x=xx)), col="green")
lines(xx, predict(fit3, data.frame(x=xx)), col="blue")
lines(xx, predict(fit4, data.frame(x=xx)), col="purple") # seems to be "best" here
best_fit = lm(y~poly(x,4,raw=TRUE))
# plot
p = ggplot(dataframe, aes(x=pH, y=mean_ratio))
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=Mean-SEM, ymax=Mean+SEM), width=.1, size=1)
p = p + scale_x_continuous(breaks=seq(5, 8, .5))
#p = p + scale_y_continuous(limits=c(0.5, 1.3), breaks=seq(0.5, 1.3, .1))
p = p + geom_smooth(method="lm", formula = y~poly(x,4), colour='blue') # "best" fit
p = p + labs(x="pH", y="normalized emission ratio")
p = p + theme_bw(base_size=24)
print(p)
# This script generates a pH calibration curve based on measurements
# taken on September 3, 2013. For these measurements cells were treated
# exactly as descibed in Brett et al. 2005, (DOI: 10.1091/mbc.E04-11-0999),
# Figure 2B.
setwd(input_dir_calibration)
# 8 pH conditions (values)
pH_values = c(4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0)
# List of files in input directory
list_files = list.files(pattern = '.txt')
list_dataframes = llply(list_files, read.delim)
list_norm_ratios = NULL
for(i in seq(2, length(list_dataframes), 2)){
# Area should always normalize to 1! Good control! Just skip the [3] indexing
# normalize to tritc/tritc channel
#norm_ratio = (list_dataframes[[i-2]][3] / list_dataframes[[i]][3]) / (list_dataframes[[i-1]][3] / list_dataframes[[i]][3])
norm_ratio = list_dataframes[[i-1]][3]  / list_dataframes[[i]][3]
list_norm_ratios = append(list_norm_ratios, norm_ratio)
rm(i, norm_ratio)
}
df_stats = NULL
for(j in seq(6, length(list_norm_ratios), 6)){
pH = pH_values[j/6]
mean_ratio = mean(unlist(list_norm_ratios[(j-5):j]))
sd_ratio = sd(unlist(list_norm_ratios[(j-5):j]))
sem_ratio = sd_ratio / sqrt(length(unlist(list_norm_ratios[(j-5):j])))
df_stats_temp = data.frame(pH, mean_ratio, sd_ratio, sem_ratio)
df_stats = rbind(df_stats, df_stats_temp)
rm(j, mean_ratio, sd_ratio, sem_ratio, pH)
}
# curve fitting
p = ggplot(df_stats, aes(x=pH, y=mean_ratio))
p = p + geom_point()
p
# what's the "best" fit?
x = df_stats$pH
y = df_stats$mean_ratio
plot(x,y,pch=19)
#fit first degree polynomial equation:
fit  <- lm(y~x)
#second degree
fit2 <- lm(y~poly(x,2,raw=TRUE))
#third degree
fit3 <- lm(y~poly(x,3,raw=TRUE))
#fourth degree
fit4 <- lm(y~poly(x,4,raw=TRUE))
#generate range of 100 numbers between highers and lowest dataframe$mean
xx <- seq(min(x), max(x), length=1000)
plot(x,y,pch=19,ylim=c(4.8, 8.2))
lines(xx, predict(fit, data.frame(x=xx)), col="red")
lines(xx, predict(fit2, data.frame(x=xx)), col="green")
lines(xx, predict(fit3, data.frame(x=xx)), col="blue")
lines(xx, predict(fit4, data.frame(x=xx)), col="purple") # seems to be "best" here
best_fit = lm(y~poly(x,4,raw=TRUE))
# plot
p = ggplot(dataframe, aes(x=pH, y=mean_ratio))
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=Mean-SEM, ymax=Mean+SEM), width=.1, size=1)
p = p + scale_x_continuous(breaks=seq(5, 8, .5))
#p = p + scale_y_continuous(limits=c(0.5, 1.3), breaks=seq(0.5, 1.3, .1))
p = p + geom_smooth(method="lm", formula = y~poly(x,4), colour='blue') # "best" fit
p = p + labs(x="pH", y="normalized emission ratio")
p = p + theme_bw(base_size=24)
print(p)
x = df_stats$pH
y = df_stats$mean_ratio
plot(x,y,pch=19)
fit  <- lm(y~x)
#second degree
fit2 <- lm(y~poly(x,2,raw=TRUE))
#third degree
fit3 <- lm(y~poly(x,3,raw=TRUE))
#fourth degree
fit4 <- lm(y~poly(x,4,raw=TRUE))
#generate range of 100 numbers between highers and lowest dataframe$mean
xx <- seq(min(x), max(x), length=1000)
plot(x,y,pch=19,ylim=c(4.8, 8.2))
p = ggplot(df_stats, aes(x=pH, y=mean_ratio))
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=Mean-SEM, ymax=Mean+SEM), width=.1, size=1)
p = p + scale_x_continuous(breaks=seq(5, 8, .5))
#p = p + scale_y_continuous(limits=c(0.5, 1.3), breaks=seq(0.5, 1.3, .1))
p = p + geom_smooth(method="lm", formula = y~poly(x,4), colour='blue') # "best" fit
p = p + labs(x="pH", y="normalized emission ratio")
p = p + theme_bw(base_size=24)
print(p)
p = ggplot(df_stats, aes(x=pH, y=mean_ratio))
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean_ratio-SEM, ymax=mean_ratio+SEM), width=.1, size=1)
p = p + scale_x_continuous(breaks=seq(5, 8, .5))
#p = p + scale_y_continuous(limits=c(0.5, 1.3), breaks=seq(0.5, 1.3, .1))
p = p + geom_smooth(method="lm", formula = y~poly(x,4), colour='blue') # "best" fit
p = p + labs(x="pH", y="normalized emission ratio")
p = p + theme_bw(base_size=24)
print(p)
p = ggplot(df_stats, aes(x=pH, y=mean_ratio))
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean_ratio-sem, ymax=mean_ratio+sem), width=.1, size=1)
p = p + scale_x_continuous(breaks=seq(5, 8, .5))
#p = p + scale_y_continuous(limits=c(0.5, 1.3), breaks=seq(0.5, 1.3, .1))
p = p + geom_smooth(method="lm", formula = y~poly(x,4), colour='blue') # "best" fit
p = p + labs(x="pH", y="normalized emission ratio")
p = p + theme_bw(base_size=24)
print(p)
View(df_stats)
# plot
p = ggplot(df_stats, aes(x=pH, y=mean_ratio))
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean_ratio-sem_ratio, ymax=mean_ratio+sem_ratio), width=.1, size=1)
p = p + scale_x_continuous(breaks=seq(5, 8, .5))
#p = p + scale_y_continuous(limits=c(0.5, 1.3), breaks=seq(0.5, 1.3, .1))
p = p + geom_smooth(method="lm", formula = y~poly(x,4), colour='blue') # "best" fit
p = p + labs(x="pH", y="normalized emission ratio")
p = p + theme_bw(base_size=24)
print(p)
plot(x,y,pch=19)
fit  <- lm(y~x)
#second degree
fit2 <- lm(y~poly(x,2,raw=TRUE))
#third degree
fit3 <- lm(y~poly(x,3,raw=TRUE))
#fourth degree
fit4 <- lm(y~poly(x,4,raw=TRUE))
xx <- seq(min(x), max(x), length=1000)
plot(x,y,pch=19,ylim=c(4.8, 8.2))
plot(x,y,pch=19,ylim=c(4.5, 8.0))
lines(xx, predict(fit, data.frame(x=xx)), col="red")
p = ggplot(df_stats, aes(x=pH, y=mean_ratio))
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean_ratio-sem_ratio, ymax=mean_ratio+sem_ratio), width=.1, size=1)
p = p + scale_x_continuous(breaks=seq(5, 8, .5))
#p = p + scale_y_continuous(limits=c(0.5, 1.3), breaks=seq(0.5, 1.3, .1))
p = p + geom_smooth(method="lm", formula = y~poly(x,4), colour='blue') # "best" fit
p = p + geom_smooth(method="lm", formula = y~poly(x,3), colour='red') # "best" fit
p = p + labs(x="pH", y="Emission ratio (AU)")
p = p + theme_bw(base_size=24)
print(p)
p = ggplot(df_stats, aes(x=pH, y=mean_ratio))
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean_ratio-sem_ratio, ymax=mean_ratio+sem_ratio), width=.1, size=1)
p = p + scale_x_continuous(breaks=seq(5, 8, .5))
#p = p + scale_y_continuous(limits=c(0.5, 1.3), breaks=seq(0.5, 1.3, .1))
p = p + geom_smooth(method="lm", formula = y~poly(x,2), colour='green') # "best" fit
p = p + geom_smooth(method="lm", formula = y~poly(x,3), colour='red') # "best" fit
p = p + geom_smooth(method="lm", formula = y~poly(x,4), colour='blue') # "best" fit
p = p + labs(x="pH", y="Emission ratio (AU)")
p = p + theme_bw(base_size=24)
print(p)
p = ggplot(df_stats, aes(x=pH, y=mean_ratio))
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean_ratio-sem_ratio, ymax=mean_ratio+sem_ratio), width=.1, size=1)
p = p + scale_x_continuous(breaks=seq(5, 8, .5))
#p = p + scale_y_continuous(limits=c(0.5, 1.3), breaks=seq(0.5, 1.3, .1))
p = p + geom_smooth(method="lm", formula = y~poly(x,2), colour='green') # "best" fit
#p = p + geom_smooth(method="lm", formula = y~poly(x,3), colour='red') # "best" fit
#p = p + geom_smooth(method="lm", formula = y~poly(x,4), colour='blue') # "best" fit
p = p + labs(x="pH", y="Emission ratio (AU)")
p = p + theme_bw(base_size=24)
print(p)
# plot
p = ggplot(df_stats, aes(x=pH, y=mean_ratio))
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean_ratio-sem_ratio, ymax=mean_ratio+sem_ratio), width=.1, size=1)
p = p + scale_x_continuous(breaks=seq(5, 8, .5))
#p = p + scale_y_continuous(limits=c(0.5, 1.3), breaks=seq(0.5, 1.3, .1))
#p = p + geom_smooth(method="lm", formula = y~poly(x,2), colour='green') # "best" fit
p = p + geom_smooth(method="lm", formula = y~poly(x,3), colour='red') # "best" fit
#p = p + geom_smooth(method="lm", formula = y~poly(x,4), colour='blue') # "best" fit
p = p + labs(x="pH", y="Emission ratio (AU)")
p = p + theme_bw(base_size=24)
print(p)
p = ggplot(df_stats, aes(x=pH, y=mean_ratio))
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean_ratio-sem_ratio, ymax=mean_ratio+sem_ratio), width=.1, size=1)
p = p + scale_x_continuous(breaks=seq(5, 8, .5))
#p = p + scale_y_continuous(limits=c(0.5, 1.3), breaks=seq(0.5, 1.3, .1))
#p = p + geom_smooth(method="lm", formula = y~poly(x,2), colour='green')
p = p + geom_smooth(method="lm", formula = y~poly(x,3), colour='red')
p = p + geom_smooth(method="lm", formula = y~poly(x,4), colour='blue') # "best" fit
p = p + labs(x="pH", y="Emission ratio (AU)")
p = p + theme_bw(base_size=24)
print(p)
