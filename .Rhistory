<<<<<<< HEAD
# save.plot(p, "DNP_all_pH.pdf", 9, 6)
sorb_4mM = subset(df_final, time<=31)
sorb_4mM = subset(df_final, time<=31)
# Plot
p = ggplot(sorb_4mM, aes(x=time, y=mean))
p = p + geom_line(size=1.8, colour="blue")
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1.2, width=5)
#p = p + scale_x_continuous(limits=c(-5, 300), breaks=seq(0, 300, 60))
=======
p = p + geom_line(size=1, colour="red")
p = p + geom_point(size=3)
p = p + geom_errorbar(aes(ymin=mean_pH-sd_pH, ymax=mean_pH+sd_pH), size=1, width=4)
p = p + scale_x_continuous(limits=c(0, 95), breaks=seq(0, 95, 5))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(x="time [min]", y="pH")
p = p + theme_bw(base_size=24)
p
p = ggplot(df_pH, aes(x=timepoint, y=mean_pH))
p = p + geom_line(size=1, colour="red")
p = p + geom_point(size=3)
p = p + geom_errorbar(aes(ymin=mean_pH-sd_pH, ymax=mean_pH+sd_pH), size=1, width=4)
p = p + scale_x_continuous(limits=c(0, 95), breaks=seq(0, 95, 10))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(x="time [min]", y="pH")
p = p + theme_bw(base_size=24)
p
name = 'Energy depletion' # Used as plot title and plot filename
p = ggplot(df_pH, aes(x=timepoint, y=mean_pH))
p = p + geom_line(size=1, colour="red")
p = p + geom_point(size=3)
p = p + geom_errorbar(aes(ymin=mean_pH-sd_pH, ymax=mean_pH+sd_pH), size=1, width=4)
p = p + scale_x_continuous(limits=c(0, 95), breaks=seq(0, 95, 10))
>>>>>>> no_segmentation
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(x="time [min]", y="pH")
p = p + theme_bw(base_size=28)
p
<<<<<<< HEAD
#### Measure pH with pHluorin2 ###
##
## Timeseries in CellASICS chamber##
##
####
# Set working directory -------------------------------------------------------
=======
# Save plot
ggsave(p, file=paste(output_dir, "/", name, ".pdf", sep=""), width=9, height=6)
p = ggplot(df_pH, aes(x=timepoint, y=mean_pH))
p = p + geom_line(size=1, colour="red")
p = p + geom_point(size=3)
p = p + geom_errorbar(aes(ymin=mean_pH-sd_pH, ymax=mean_pH+sd_pH), size=1, width=4)
p = p + scale_x_continuous(limits=c(-5, 95), breaks=seq(0, 95, 10))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(title=name, x="time [min]", y="pH")
p = p + theme_bw(base_size=24)
p
p = ggplot(df_pH, aes(x=timepoint, y=mean_pH))
p = p + geom_line(size=1, colour="red")
p = p + geom_point(size=3)
p = p + geom_errorbar(aes(ymin=mean_pH-sd_pH, ymax=mean_pH+sd_pH), size=1, width=4)
p = p + scale_x_continuous(limits=c(-2, 95), breaks=seq(0, 95, 10))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(title=name, x="time [min]", y="pH")
p = p + theme_bw(base_size=24)
p
ggsave(p, file=paste(output_dir, "/", name, ".pdf", sep=""), width=9, height=6)
ggsave(p, file=paste(output_dir, "/", name, ".pdf", sep=""), width=6, height=5)
rm(list=ls()) # clean up
# Measure pH with pHluorin2
#
# This script analyses a time series of pH measurements. For a closer
# description see <add bitbucket repo>.
# Clean up environment
>>>>>>> no_segmentation
rm(list=ls()) # clean up
# Load required packeges
library("ggplot2")
library("plyr")
<<<<<<< HEAD
#library("tcltk")
# Set parameters --------------------------------------------------------------
# Please adjust all of the following parameters
unit = "A"
dir_output = "/Users/munder/Git/pH-calculator/"
folder_output = "output/" # give name of output folder here
time_res = 10 # in minutes
timepoints = 67
field_of_views = 6
=======
library("hash")
library("readr")
library("tcltk")
library("tcltk2")
# Please adjust all of the following parameter(s)
time_resolution =  5 # in minutes
field_of_views = 6
timepoints = 25
name = 'Energy depletion' # Used as plot title and plot filename
# Set directories ---------------------------------------------------------
working_dir = tk_choose.dir(caption=("Choose working directory!"))
input_dir_measurements = tk_choose.dir(caption=("Select input directory containing measurement results."))
input_dir_calibration = tk_choose.dir(caption=("Select directory containing calibration data."))
output_dir = tk_choose.dir(caption=("Select output directory. Dataframes and plots will be saved here."))
>>>>>>> no_segmentation
# Define functions ------------------------------------------------------------
calc.pH = function(emission_ratio, model){
#browser()
coefs = coef(model)
#y = a + bx + cx^2 + dx^3 + ex^4
calculated_pH = coefs[1] +
(coefs[2] * emission_ratio) +
(coefs[3] * emission_ratio^2) +
(coefs[4] * emission_ratio^3) +
(coefs[5] * emission_ratio^4)
return(calculated_pH)
}
stats = function(df){
#browser()
mean<- mean(df$pH)
sd <- sd(df$pH)
sem <- sd / sqrt(length(df))
data.frame(mean, sd, sem)
}
<<<<<<< HEAD
# remove background
rm.bg = function(df_bg, ff_bg){
background = seq(0, 100, length=1000)
for(i in seq_along(background)){
#browser()
bg = background[i]
cor_df_bg = df_bg - bg
cor_ff_bg = ff_bg - bg
ratio = cor_df_bg / cor_ff_bg
mean_ratio = mean(ratio)
pH = as.numeric(calc.pH(mean_ratio, best_fit))
if(round(pH, digits=3)==7.400){
#print(bg)
#print(pH)
return(bg)
}
}
=======
# Calibrate ---------------------------------------------------------------
setwd(working_dir)
source("calibrate.R")
# Measure -----------------------------------------------------------------
setwd(input_dir_measurements)
# Loop throgh timepoints, calculate dapi/fitc to fifc/fitc ratios,
# concatenate ratios for each timepoint and compute mean and sd of
# ratios. If segmentation in Fiji would be perfect (each ROI=1 cell),
# the mean would be the mean ratio per cell, sd would show how much
# the pH varies between cells etc. Right now segmentation is NOT perfect!
df_pH = NULL
for (i in 1:timepoints) {
# Generate file list for fitc/fitc and dapi/fitc channels for
# one timepoint:
if (i < 10) {
list_files_df = list.files(pattern = paste('_df_', '0', i, sep=''))
list_files_ff = list.files(pattern = paste('_ff_', '0', i, sep=''))
} else {
list_files_df = list.files(pattern = paste('_df_', i, sep=''))
list_files_ff = list.files(pattern = paste('_ff_', i, sep=''))
}
# Read in files with Hadley's readr function read_tsv
list_data_df = llply(list_files_df, read_tsv)
list_data_ff = llply(list_files_ff, read_tsv)
# Combine all measurements for one timepoint... So stupid! Ugliest way ever to
# avoid a nested loop. How the hell can I slice a list in R? Or do an
# apply(list$Mean, mean) on list_data_df etc...
values_df = unlist(list_data_df)
values_ff = unlist(list_data_ff)
ratios = values_df[c(grep("Mean", names(values_df)))] /
values_ff[c(grep("Mean", names(values_ff)))]
# calculate pH values;  mean and sd
mean_pH = mean(calc_pH(ratios, best_fit))
sd_pH = sd(calc_pH(ratios, best_fit))
df_pH_tmp = data.frame(timepoint=(i-1)*time_resolution, mean_pH=mean_pH, sd_pH=sd_pH)
df_pH = rbind(df_pH, df_pH_tmp)
}
# Plot
p = ggplot(df_pH, aes(x=timepoint, y=mean_pH))
p = p + geom_line(size=1, colour="red")
p = p + geom_point(size=3)
p = p + geom_errorbar(aes(ymin=mean_pH-sd_pH, ymax=mean_pH+sd_pH), size=1, width=4)
p = p + scale_x_continuous(limits=c(-2, 95), breaks=seq(0, 95, 10))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(title=name, x="time [min]", y="pH")
p = p + theme_bw(base_size=24)
p
# Save plot
ggsave(p, file=paste(output_dir, "/", name, ".pdf", sep=""), width=6, height=5)
# Measure pH with pHluorin2
#
# This script analyses a time series of pH measurements. For a closer
# description see <add bitbucket repo>.
# Clean up environment
rm(list=ls()) # clean up
# Load required packeges
library("ggplot2")
library("plyr")
#library("hash")
library("readr")
library("tcltk")
library("tcltk2")
# Please adjust all of the following parameter(s)
time_resolution =  5 # in minutes
field_of_views = 6
timepoints = 25
name = 'Energy depletion' # Used as plot title and plot filename
# Set directories ---------------------------------------------------------
working_dir = tk_choose.dir(caption=("Choose working directory!"))
input_dir_measurements = tk_choose.dir(caption=("Select input directory containing measurement results."))
input_dir_calibration = tk_choose.dir(caption=("Select directory containing calibration data."))
output_dir = tk_choose.dir(caption=("Select output directory. Dataframes and plots will be saved here."))
# Define functions ------------------------------------------------------------
calc_pH = function(emission_ratio, model){
coefs = coef(model)
#y = a + bx + cx^2 + dx^3 + ex^4
calculated_pH = coefs[1] +
(coefs[2] * emission_ratio) +
(coefs[3] * emission_ratio^2) +
(coefs[4] * emission_ratio^3) +
(coefs[5] * emission_ratio^4)
return(calculated_pH)
>>>>>>> no_segmentation
}
write.reload = function(filename){
# write
write.table(get(filename),
paste(dir_output, folder_output, filename, ".txt", sep=""), sep="\t")
# reload
assign(filename,
read.delim(paste(dir_output, folder_output, filename, ".txt", sep="")))
}
<<<<<<< HEAD
save.plot = function(plot, file_name, width, height){
setwd(paste(dir_output, folder_output, sep=""))
ggsave(p, file=file_name, width=width, height=height)
setwd(directory)
}
# Calibrate
source(paste(directory, "/calibrate/calibrate.R", sep=""))  #/old
# loop for plotting differnt measurements together
# units = c("A", "B", "C", "D")
#
# for(i in 1 :4){
#
#   unit = units[i]
# Read files
setwd(paste(directory, "input_CellASIC", sep=""))
temp <- list.files(pattern=unit)
list <- sapply(temp, read.delim)
list <- t(list)
mean = sapply(list[,"Mean"], mean)
raw_data = ldply(mean)
# tags
# field of view
fov = NULL
for(i in 1:field_of_views){
fov_temp = rep(i, timepoints*2)
fov = c(fov, fov_temp)
}
#channel
channel = c(rep("df", timepoints), rep("ff", timepoints))
# timestamp
time = (seq(0, timepoints-1, 1)) * time_res
dataframe = cbind(unit, channel, time, fov, raw_data)
colnames(dataframe) = c("unit", "channel", "time", "fov", "id", "counts")
# Test more substraction
bg = 5
dataframe$counts = dataframe$counts - bg
ratios = (subset(dataframe, channel=="df"))$counts / (subset(dataframe, channel=="ff"))$counts
# # Read files in a for loop
# setwd(paste(directory, "input_CELLASIC", sep=""))
#
# # FITC/FITC
# df_ff = NULL
# for(i in 1:field_of_views){
#   #FITC/FITC
#   df_ff_temp = read.delim(paste("Results_", condition, "_0", i, "_ff", ".txt", sep=""))
#   time = df_ff_temp$X*timeRes-10
#   replicate = rep(i, nrow(df_ff_temp))
#   channel = rep("ff", nrow(df_ff_temp))
#   df_ff_temp = cbind(df_ff_temp, time, replicate, channel)
#   df_ff = rbind(df_ff, df_ff_temp)
# }
#
# # DAPI/FITC
# df_df = NULL
# for(i in 1:field_of_views){
#   #FITC/FITC
#   df_df_temp = read.delim(paste("Results_", condition, "_0", i, "_df", ".txt", sep=""))
#   time = df_ff_temp$X*timeRes-10
#   replicate = rep(i, nrow(df_df_temp))
#   channel = rep("df", nrow(df_df_temp))
#   df_df_temp = cbind(df_df_temp, time, replicate, channel)
#   df_df = rbind(df_df, df_df_temp)
# }
# Correct for autofluorescence background (this assumes that intracellular pH is at pH 7.4
# in log phase cells and uses this asumption to substract background from both channels
# df_bg = ((ddply(df_df, .(time), summarize, mean=mean(Mean1)))$mean)[1:6]
# ff_bg = ((ddply(df_ff, .(time), summarize, mean=mean(Mean1)))$mean)[1:6]
#
# bg = rm.bg(df_bg, ff_bg)
# bg = 50
#
# df_df$Mean1 = df_df$Mean1 - bg
# df_ff$Mean1 = df_ff$Mean1 - bg
# Ratios
# df_ratios = cbind(df_ff$time, df_ff$replicate, df_df$Mean1/df_ff$Mean1))
# colnames(df_ratios) = c("time", "replicate", "ratio")
# Normalize
#norm_ratios = df_ratios$ratio/mean_ratio_70
# Calc pH
pH = calc.pH(ratios, best_fit)
# Final dataframe
df_pH = as.data.frame(cbind(unit, time, ratios, pH))
df_pH$pH = as.numeric(as.character(df_pH$pH))
df_pH$time = as.numeric(as.character(df_pH$time))
# Get stats over time
df_final = ddply(df_pH, .(time, unit), stats)
assign(paste("df_", unit, sep=""), df_final)
write.reload(paste("df_", unit, sep=""))
sorb_4mM = subset(df_final, time<=310)
# Plot
p = ggplot(sorb_4mM, aes(x=time, y=mean))
p = p + geom_line(size=1.8, colour="blue")
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1.2, width=5)
#p = p + scale_x_continuous(limits=c(-5, 300), breaks=seq(0, 300, 60))
=======
# Calibrate ---------------------------------------------------------------
setwd(working_dir)
source("calibrate.R")
# Measure -----------------------------------------------------------------
setwd(input_dir_measurements)
# Loop throgh timepoints, calculate dapi/fitc to fifc/fitc ratios,
# concatenate ratios for each timepoint and compute mean and sd of
# ratios. If segmentation in Fiji would be perfect (each ROI=1 cell),
# the mean would be the mean ratio per cell, sd would show how much
# the pH varies between cells etc. Right now segmentation is NOT perfect!
df_pH = NULL
for (i in 1:timepoints) {
# Generate file list for fitc/fitc and dapi/fitc channels for
# one timepoint:
if (i < 10) {
list_files_df = list.files(pattern = paste('_df_', '0', i, sep=''))
list_files_ff = list.files(pattern = paste('_ff_', '0', i, sep=''))
} else {
list_files_df = list.files(pattern = paste('_df_', i, sep=''))
list_files_ff = list.files(pattern = paste('_ff_', i, sep=''))
}
# Read in files with Hadley's readr function read_tsv
list_data_df = llply(list_files_df, read_tsv)
list_data_ff = llply(list_files_ff, read_tsv)
# Combine all measurements for one timepoint... So stupid! Ugliest way ever to
# avoid a nested loop. How the hell can I slice a list in R? Or do an
# apply(list$Mean, mean) on list_data_df etc...
values_df = unlist(list_data_df)
values_ff = unlist(list_data_ff)
ratios = values_df[c(grep("Mean", names(values_df)))] /
values_ff[c(grep("Mean", names(values_ff)))]
# calculate pH values;  mean and sd
mean_pH = mean(calc_pH(ratios, best_fit))
sd_pH = sd(calc_pH(ratios, best_fit))
df_pH_tmp = data.frame(timepoint=(i-1)*time_resolution, mean_pH=mean_pH, sd_pH=sd_pH)
df_pH = rbind(df_pH, df_pH_tmp)
}
# Plot
p = ggplot(df_pH, aes(x=timepoint, y=mean_pH))
p = p + geom_line(size=1, colour="red")
p = p + geom_point(size=3)
p = p + geom_errorbar(aes(ymin=mean_pH-sd_pH, ymax=mean_pH+sd_pH), size=1, width=4)
p = p + scale_x_continuous(limits=c(-2, 95), breaks=seq(0, 95, 10))
>>>>>>> no_segmentation
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(x="time [min]", y="pH")
p = p + theme_bw(base_size=28)
p
# Save plot
<<<<<<< HEAD
setwd(paste(directory, "output", sep=""))
ggsave(p, file=paste(unit, ".pdf", sep=""), width=9, height=6)
# Plot multiple pH together
#
# setwd(directory)
#
# df_A = read.delim("output/df_A.txt")
# df_B = read.delim("output/df_B.txt")
# df_C = read.delim("output/df_C.txt")
# df_D = read.delim("output/df_D.txt")
#
# df = rbind(df_A, df_B, df_C, df_D)
#
# p = ggplot(df, aes(x=time, y=mean, colour=unit))
# p = p + geom_line(size=2)
# p = p + geom_point(size=2)
# p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1, width=5)
# p = p + scale_x_continuous(limits=c(-5, 300), breaks=seq(0, 300, 60))
# #p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
# p = p + labs(x="time [min]", y="pH")
# p = p + theme_bw(base_size=28)
# p
#
# save.plot(p, "DNP_all_pH.pdf", 9, 6)
sorb_4mM = subset(df_final, time<=200)
# Plot
p = ggplot(sorb_4mM, aes(x=time, y=mean))
p = p + geom_line(size=1.8, colour="blue")
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1.2, width=5)
#p = p + scale_x_continuous(limits=c(-5, 300), breaks=seq(0, 300, 60))
=======
ggsave(p, file=paste(output_dir, "/", name, ".pdf", sep=""), width=6, height=5)
# Measure pH with pHluorin2
#
# This script analyses a time series of pH measurements. For a closer
# description see <add bitbucket repo>.
# Clean up environment
rm(list=ls()) # clean up
# Load required packeges
library("ggplot2")
library("plyr")
#library("hash")
library("readr")
library("tcltk")
library("tcltk2")
# Please adjust all of the following parameter(s)
time_resolution =  5 # in minutes
field_of_views = 6
timepoints = 25
name = 'Heatshock' # Used as plot title and plot filename
# Set directories ---------------------------------------------------------
working_dir = tk_choose.dir(caption=("Choose working directory!"))
input_dir_measurements = tk_choose.dir(caption=("Select input directory containing measurement results."))
input_dir_calibration = tk_choose.dir(caption=("Select directory containing calibration data."))
output_dir = tk_choose.dir(caption=("Select output directory. Dataframes and plots will be saved here."))
# Define functions ------------------------------------------------------------
calc_pH = function(emission_ratio, model){
coefs = coef(model)
#y = a + bx + cx^2 + dx^3 + ex^4
calculated_pH = coefs[1] +
(coefs[2] * emission_ratio) +
(coefs[3] * emission_ratio^2) +
(coefs[4] * emission_ratio^3) +
(coefs[5] * emission_ratio^4)
return(calculated_pH)
}
stats = function(df){
mean<- mean(df$pH)
sd <- sd(df$pH)
sem <- sd / sqrt(length(df))
data.frame(mean, sd, sem)
}
# Calibrate ---------------------------------------------------------------
setwd(working_dir)
source("calibrate.R")
# Measure -----------------------------------------------------------------
setwd(input_dir_measurements)
# Loop throgh timepoints, calculate dapi/fitc to fifc/fitc ratios,
# concatenate ratios for each timepoint and compute mean and sd of
# ratios. If segmentation in Fiji would be perfect (each ROI=1 cell),
# the mean would be the mean ratio per cell, sd would show how much
# the pH varies between cells etc. Right now segmentation is NOT perfect!
df_pH = NULL
for (i in 1:timepoints) {
# Generate file list for fitc/fitc and dapi/fitc channels for
# one timepoint:
if (i < 10) {
list_files_df = list.files(pattern = paste('_df_', '0', i, sep=''))
list_files_ff = list.files(pattern = paste('_ff_', '0', i, sep=''))
} else {
list_files_df = list.files(pattern = paste('_df_', i, sep=''))
list_files_ff = list.files(pattern = paste('_ff_', i, sep=''))
}
# Read in files with Hadley's readr function read_tsv
list_data_df = llply(list_files_df, read_tsv)
list_data_ff = llply(list_files_ff, read_tsv)
# Combine all measurements for one timepoint... So stupid! Ugliest way ever to
# avoid a nested loop. How the hell can I slice a list in R? Or do an
# apply(list$Mean, mean) on list_data_df etc...
values_df = unlist(list_data_df)
values_ff = unlist(list_data_ff)
ratios = values_df[c(grep("Mean", names(values_df)))] /
values_ff[c(grep("Mean", names(values_ff)))]
# calculate pH values;  mean and sd
mean_pH = mean(calc_pH(ratios, best_fit))
sd_pH = sd(calc_pH(ratios, best_fit))
df_pH_tmp = data.frame(timepoint=(i-1)*time_resolution, mean_pH=mean_pH, sd_pH=sd_pH)
df_pH = rbind(df_pH, df_pH_tmp)
}
# Plot
p = ggplot(df_pH, aes(x=timepoint, y=mean_pH))
p = p + geom_line(size=1, colour="red")
p = p + geom_point(size=3)
p = p + geom_errorbar(aes(ymin=mean_pH-sd_pH, ymax=mean_pH+sd_pH), size=1, width=4)
p = p + scale_x_continuous(limits=c(-2, 95), breaks=seq(0, 95, 10))
>>>>>>> no_segmentation
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(x="time [min]", y="pH")
p = p + theme_bw(base_size=28)
p
<<<<<<< HEAD
#### Measure pH with pHluorin2 ###
##
## Timeseries in CellASICS chamber##
##
####
# Set working directory -------------------------------------------------------
=======
# Save plot
ggsave(p, file=paste(output_dir, "/", name, ".pdf", sep=""), width=6, height=5)
rm(list=ls()) # clean up
# Measure pH with pHluorin2
#
# This script analyses a time series of pH measurements. For a closer
# description see <add bitbucket repo>.
# Clean up environment
>>>>>>> no_segmentation
rm(list=ls()) # clean up
# Load required packeges
library("ggplot2")
library("plyr")
<<<<<<< HEAD
#library("tcltk")
# Set parameters --------------------------------------------------------------
# Please adjust all of the following parameters
unit = "A"
dir_output = "/Users/munder/Git/pH-calculator/"
folder_output = "output/" # give name of output folder here
time_res = 10 # in minutes
timepoints = 67
field_of_views = 6
=======
#library("hash")
library("readr")
library("tcltk")
library("tcltk2")
# Please adjust all of the following parameter(s)
time_resolution =  5 # in minutes
field_of_views = 6
timepoints = 25
name = 'Heatshock' # Used as plot title and plot filename
# Set directories ---------------------------------------------------------
working_dir = tk_choose.dir(caption=("Choose working directory!"))
input_dir_measurements = tk_choose.dir(caption=("Select input directory containing measurement results."))
input_dir_calibration = tk_choose.dir(caption=("Select directory containing calibration data."))
output_dir = tk_choose.dir(caption=("Select output directory. Dataframes and plots will be saved here."))
>>>>>>> no_segmentation
# Define functions ------------------------------------------------------------
calc.pH = function(emission_ratio, model){
#browser()
coefs = coef(model)
#y = a + bx + cx^2 + dx^3 + ex^4
calculated_pH = coefs[1] +
(coefs[2] * emission_ratio) +
(coefs[3] * emission_ratio^2) +
(coefs[4] * emission_ratio^3) +
(coefs[5] * emission_ratio^4)
return(calculated_pH)
}
stats = function(df){
#browser()
mean<- mean(df$pH)
sd <- sd(df$pH)
sem <- sd / sqrt(length(df))
data.frame(mean, sd, sem)
}
<<<<<<< HEAD
# remove background
rm.bg = function(df_bg, ff_bg){
background = seq(0, 100, length=1000)
for(i in seq_along(background)){
#browser()
bg = background[i]
cor_df_bg = df_bg - bg
cor_ff_bg = ff_bg - bg
ratio = cor_df_bg / cor_ff_bg
mean_ratio = mean(ratio)
pH = as.numeric(calc.pH(mean_ratio, best_fit))
if(round(pH, digits=3)==7.400){
#print(bg)
#print(pH)
return(bg)
}
}
}
write.reload = function(filename){
# write
write.table(get(filename),
paste(dir_output, folder_output, filename, ".txt", sep=""), sep="\t")
# reload
assign(filename,
read.delim(paste(dir_output, folder_output, filename, ".txt", sep="")))
}
save.plot = function(plot, file_name, width, height){
setwd(paste(dir_output, folder_output, sep=""))
ggsave(p, file=file_name, width=width, height=height)
setwd(directory)
}
# Calibrate
source(paste(directory, "/calibrate/calibrate.R", sep=""))  #/old
# loop for plotting differnt measurements together
# units = c("A", "B", "C", "D")
#
# for(i in 1 :4){
#
#   unit = units[i]
# Read files
setwd(paste(directory, "input_CellASIC", sep=""))
temp <- list.files(pattern=unit)
list <- sapply(temp, read.delim)
list <- t(list)
mean = sapply(list[,"Mean"], mean)
raw_data = ldply(mean)
# tags
# field of view
fov = NULL
for(i in 1:field_of_views){
fov_temp = rep(i, timepoints*2)
fov = c(fov, fov_temp)
}
#channel
channel = c(rep("df", timepoints), rep("ff", timepoints))
# timestamp
time = (seq(0, timepoints-1, 1)) * time_res
dataframe = cbind(unit, channel, time, fov, raw_data)
colnames(dataframe) = c("unit", "channel", "time", "fov", "id", "counts")
# Test more substraction
bg = 5
dataframe$counts = dataframe$counts - bg
ratios = (subset(dataframe, channel=="df"))$counts / (subset(dataframe, channel=="ff"))$counts
# # Read files in a for loop
# setwd(paste(directory, "input_CELLASIC", sep=""))
#
# # FITC/FITC
# df_ff = NULL
# for(i in 1:field_of_views){
#   #FITC/FITC
#   df_ff_temp = read.delim(paste("Results_", condition, "_0", i, "_ff", ".txt", sep=""))
#   time = df_ff_temp$X*timeRes-10
#   replicate = rep(i, nrow(df_ff_temp))
#   channel = rep("ff", nrow(df_ff_temp))
#   df_ff_temp = cbind(df_ff_temp, time, replicate, channel)
#   df_ff = rbind(df_ff, df_ff_temp)
# }
#
# # DAPI/FITC
# df_df = NULL
# for(i in 1:field_of_views){
#   #FITC/FITC
#   df_df_temp = read.delim(paste("Results_", condition, "_0", i, "_df", ".txt", sep=""))
#   time = df_ff_temp$X*timeRes-10
#   replicate = rep(i, nrow(df_df_temp))
#   channel = rep("df", nrow(df_df_temp))
#   df_df_temp = cbind(df_df_temp, time, replicate, channel)
#   df_df = rbind(df_df, df_df_temp)
# }
# Correct for autofluorescence background (this assumes that intracellular pH is at pH 7.4
# in log phase cells and uses this asumption to substract background from both channels
# df_bg = ((ddply(df_df, .(time), summarize, mean=mean(Mean1)))$mean)[1:6]
# ff_bg = ((ddply(df_ff, .(time), summarize, mean=mean(Mean1)))$mean)[1:6]
#
# bg = rm.bg(df_bg, ff_bg)
# bg = 50
#
# df_df$Mean1 = df_df$Mean1 - bg
# df_ff$Mean1 = df_ff$Mean1 - bg
# Ratios
# df_ratios = cbind(df_ff$time, df_ff$replicate, df_df$Mean1/df_ff$Mean1))
# colnames(df_ratios) = c("time", "replicate", "ratio")
# Normalize
#norm_ratios = df_ratios$ratio/mean_ratio_70
# Calc pH
pH = calc.pH(ratios, best_fit)
# Final dataframe
df_pH = as.data.frame(cbind(unit, time, ratios, pH))
df_pH$pH = as.numeric(as.character(df_pH$pH))
df_pH$time = as.numeric(as.character(df_pH$time))
# Get stats over time
df_final = ddply(df_pH, .(time, unit), stats)
assign(paste("df_", unit, sep=""), df_final)
write.reload(paste("df_", unit, sep=""))
sorb_6mM = subset(df_final, time>=200)
# Plot
p = ggplot(sorb_6mM, aes(x=time, y=mean))
p = p + geom_line(size=1.8, colour="blue")
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1.2, width=5)
#p = p + scale_x_continuous(limits=c(-5, 300), breaks=seq(0, 300, 60))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(x="time [min]", y="pH")
p = p + theme_bw(base_size=28)
p
# Save plot
#setwd(paste(directory, "output", sep=""))
#ggsave(p, file=paste(sorb_mM, ".pdf", sep=""), width=9, height=6)
# Plot multiple pH together
#
# setwd(directory)
#
# df_A = read.delim("output/df_A.txt")
# df_B = read.delim("output/df_B.txt")
# df_C = read.delim("output/df_C.txt")
# df_D = read.delim("output/df_D.txt")
#
# df = rbind(df_A, df_B, df_C, df_D)
#
# p = ggplot(df, aes(x=time, y=mean, colour=unit))
# p = p + geom_line(size=2)
# p = p + geom_point(size=2)
# p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1, width=5)
# p = p + scale_x_continuous(limits=c(-5, 300), breaks=seq(0, 300, 60))
# #p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
# p = p + labs(x="time [min]", y="pH")
# p = p + theme_bw(base_size=28)
# p
#
# save.plot(p, "DNP_all_pH.pdf", 9, 6)
setwd(paste(directory, "output", sep=""))
ggsave(p, file=paste(sorb_6mM, ".pdf", sep=""), width=9, height=6)
write.reload(paste("sorb_6mM", sep=""))
p = ggplot(sorb_6mM, aes(x=time, y=mean))
p = p + geom_line(size=1.8, colour="blue")
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1.2, width=5)
#p = p + scale_x_continuous(limits=c(-5, 300), breaks=seq(0, 300, 60))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(x="time [min]", y="pH")
p = p + theme_bw(base_size=28)
p
sorb_6mM = subset(df_final, time>=300)
# Plot
p = ggplot(sorb_6mM, aes(x=time, y=mean))
p = p + geom_line(size=1.8, colour="blue")
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1.2, width=5)
#p = p + scale_x_continuous(limits=c(-5, 300), breaks=seq(0, 300, 60))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(x="time [min]", y="pH")
p = p + theme_bw(base_size=28)
p
setwd(paste(directory, "output", sep=""))
ggsave(p, file=paste(sorb_6mM, ".pdf", sep=""), width=9, height=6)
sorb_6mM = subset(df_final, 300<=time<=500)
# Plot
p = ggplot(sorb_6mM, aes(x=time, y=mean))
p = p + geom_line(size=1.8, colour="blue")
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1.2, width=5)
#p = p + scale_x_continuous(limits=c(-5, 300), breaks=seq(0, 300, 60))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(x="time [min]", y="pH")
p = p + theme_bw(base_size=28)
p
sorb_6mM = subset(df_final, 300<=time<=500)
sorb_6mM = subset(df_final, time>=300 & time<=500)
p = ggplot(sorb_6mM, aes(x=time, y=mean))
p = p + geom_line(size=1.8, colour="blue")
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1.2, width=5)
#p = p + scale_x_continuous(limits=c(-5, 300), breaks=seq(0, 300, 60))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(x="time [min]", y="pH")
p = p + theme_bw(base_size=28)
p
write.reload(paste("sorb_6mM", sep=""))
sorb_4mM = subset(df_final, time<=200)
sorb_4mM = subset(df_final, time<=200)
# Plot
p = ggplot(sorb_4mM, aes(x=time, y=mean))
p = p + geom_line(size=1.8, colour="blue")
p = p + geom_point(size=4)
p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1.2, width=5)
#p = p + scale_x_continuous(limits=c(-5, 300), breaks=seq(0, 300, 60))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(x="time [min]", y="pH")
p = p + theme_bw(base_size=28)
p
write.reload(paste("sorb_4mM", sep=""))
df_sorb4mM = read.delim("output/sorb4mM.txt")
df_sorb6mM = read.delim("output/sorb6mM.txt")
setwd(directory)
#
df_sorb4mM = read.delim("output/sorb4mM.txt")
df_sorb6mM = read.delim("output/sorb6mM.txt")
df_sorb4mM = read.delim("output/sorb_4mM.txt")
df_sorb6mM = read.delim("output/sorb_6mM.txt")
df = rbind(df_A, df_B, df_C, df_D)
p = ggplot(df, aes(x=time, y=mean, colour=unit))
p = p + geom_line(size=2)
p = p + geom_point(size=2)
p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1, width=5)
p = p + scale_x_continuous(limits=c(-5, 300), breaks=seq(0, 300, 60))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(x="time [min]", y="pH")
p = p + theme_bw(base_size=28)
p
View(df_sorb4mM)
View(df_sorb6mM)
View(sorb_4mM)
View(sorb_6mM)
View(sorb_4mM)
sorb_6mM = subset(df_final, time>=300 & time<=500)
sorb_6mM = subset(df_final, time>=300 & time<=500)
write.reload(paste("sorb_6mM", sep=""))
df_sorb4mM = read.delim("output/sorb_4mM.txt")
df_sorb6mM = read.delim("output/sorb_6mM.txt")
View(df_sorb4mM)
View(df_sorb6mM)
View(df_sorb4mM)
View(df_sorb6mM)
df = rbind(df_sorb4mM, df_sorb6mM)
View(df)
View(df_sorb6mM)
df_sorb6mM$time = df_sorb6mM$time - 300
df_sorb6mM$unit = "test"
View(df_sorb6mM)
df = rbind(df_sorb4mM, df_sorb6mM)
write.reload(paste("sorb_6mM", sep=""))
df = rbind(df_sorb4mM, df_sorb6mM)
p = ggplot(df, aes(x=time, y=mean, colour=unit))
p = p + geom_line(size=2)
p = p + geom_point(size=2)
p = p + geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), size=1, width=5)
p = p + scale_x_continuous(limits=c(-5, 300), breaks=seq(0, 300, 60))
#p = p + scale_y_continuous(breaks=seq(6.6, 7.8, 0.1))
p = p + labs(x="time [min]", y="pH")
p = p + theme_bw(base_size=28)
p
df_sorb6mM$unit = "sorb6mM"
write.reload(paste("sorb_6mM", sep=""))
write.reload(paste("df_sorb6mM", sep=""))
df_sorb4mM$unit = "sorb4mM"
write.reload(paste("df_sorb4mM", sep=""))
=======
# Calibrate ---------------------------------------------------------------
setwd(working_dir)
source("calibrate.R")
# Measure -----------------------------------------------------------------
setwd(input_dir_measurements)
# Loop throgh timepoints, calculate dapi/fitc to fifc/fitc ratios,
# concatenate ratios for each timepoint and compute mean and sd of
# ratios. If segmentation in Fiji would be perfect (each ROI=1 cell),
# the mean would be the mean ratio per cell, sd would show how much
# the pH varies between cells etc. Right now segmentation is NOT perfect!
df_pH = NULL
for (i in 1:timepoints) {
# Generate file list for fitc/fitc and dapi/fitc channels for
# one timepoint:
if (i < 10) {
list_files_df = list.files(pattern = paste('_df_', '0', i, sep=''))
list_files_ff = list.files(pattern = paste('_ff_', '0', i, sep=''))
} else {
list_files_df = list.files(pattern = paste('_df_', i, sep=''))
list_files_ff = list.files(pattern = paste('_ff_', i, sep=''))
}
# Read in files with Hadley's readr function read_tsv
list_data_df = llply(list_files_df, read_tsv)
list_data_ff = llply(list_files_ff, read_tsv)
# Combine all measurements for one timepoint... So stupid! Ugliest way ever to
# avoid a nested loop. How the hell can I slice a list in R? Or do an
# apply(list$Mean, mean) on list_data_df etc...
values_df = unlist(list_data_df)
values_ff = unlist(list_data_ff)
intensities_df = values_df[c(grep("Mean", names(values_df)))]
intensities_ff = values_ff[c(grep("Mean", names(values_ff)))]
ratios = intensities_df / intensities_ff
# calculate pH values;  mean and sd
mean_pH = mean(calc_pH(ratios, best_fit))
sd_pH = sd(calc_pH(ratios, best_fit))
df_pH_tmp = data.frame(timepoint=(i-1)*time_resolution, mean_df = mean(intensities_df),
mean_ff = mean(intensities_ff), mean_pH=mean_pH, sd_pH=sd_pH)
df_pH = rbind(df_pH, df_pH_tmp)
}
# Plot
p = ggplot(df_pH, aes(x=timepoint, y=mean_pH))
p = p + geom_line(size=1, colour="red")
p = p + geom_point(size=3)
p = p + geom_errorbar(aes(ymin=mean_pH-sd_pH, ymax=mean_pH+sd_pH), size=1, width=4)
p = p + scale_x_continuous(limits=c(-2, 125), breaks=seq(0, 125, 10))
p = p + scale_y_continuous(breaks=seq(5.8, 7.8, 0.2))
p = p + labs(title=name, x="time [min]", y="pH")
p = p + theme_bw(base_size=24)
p
# Save plot
ggsave(p, file=paste(output_dir, "/", name, ".pdf", sep=""), width=8, height=5)
write_tsv(df_pH, '')
write_tsv(df_pH, 'df_pH_heatshock.txt')
# Save plot and dataframe
setwd(output_dir)
ggsave(p, file=paste(name, ".pdf", sep=""), width=8, height=5)
write_tsv(df_pH, 'df_pH_heatshock.txt')
setwd(working_dir)
View(df_pH)
write_tsv(df_pH, 'df_pH_heatshock.txt')
setwd(output_dir)
write_csv(df_pH, 'df_pH_heatshock.txt')
write_tsv(df_pH, paste('df_pH_', name, '.txt', sep=''))
write_csv(df_pH, paste('df_pH_', name, '.csv', sep=''))
# Measure pH with pHluorin2
#
# This script analyses a time series of pH measurements. For a closer
# description see <add bitbucket repo>.
# Clean up environment
rm(list=ls()) # clean up
# Load required packeges
library("ggplot2")
library("plyr")
#library("hash")
library("readr")
library("tcltk")
library("tcltk2")
# Please adjust all of the following parameter(s)
time_resolution =  5 # in minutes
field_of_views = 6
timepoints = 19
name = 'Energy depletion' # Used as plot title and plot filename
# Set directories ---------------------------------------------------------
working_dir = tk_choose.dir(caption=("Choose working directory!"))
input_dir_measurements = tk_choose.dir(caption=("Select input directory containing measurement results."))
input_dir_calibration = tk_choose.dir(caption=("Select directory containing calibration data."))
output_dir = tk_choose.dir(caption=("Select output directory. Dataframes and plots will be saved here."))
# Define functions ------------------------------------------------------------
calc_pH = function(emission_ratio, model){
coefs = coef(model)
#y = a + bx + cx^2 + dx^3 + ex^4
calculated_pH = coefs[1] +
(coefs[2] * emission_ratio) +
(coefs[3] * emission_ratio^2) +
(coefs[4] * emission_ratio^3) +
(coefs[5] * emission_ratio^4)
return(calculated_pH)
}
# Calibrate ---------------------------------------------------------------
setwd(working_dir)
source("calibrate.R")
# Measure -----------------------------------------------------------------
setwd(input_dir_measurements)
# Loop throgh timepoints, calculate dapi/fitc to fifc/fitc ratios,
# concatenate ratios for each timepoint and compute mean and sd of
# ratios. If segmentation in Fiji would be perfect (each ROI=1 cell),
# the mean would be the mean ratio per cell, sd would show how much
# the pH varies between cells etc. Right now segmentation is NOT perfect!
df_pH = NULL
for (i in 1:timepoints) {
# Generate file list for fitc/fitc and dapi/fitc channels for
# one timepoint:
if (i < 10) {
list_files_df = list.files(pattern = paste('_df_', '0', i, sep=''))
list_files_ff = list.files(pattern = paste('_ff_', '0', i, sep=''))
} else {
list_files_df = list.files(pattern = paste('_df_', i, sep=''))
list_files_ff = list.files(pattern = paste('_ff_', i, sep=''))
}
# Read in files with Hadley's readr function read_tsv
list_data_df = llply(list_files_df, read_tsv)
list_data_ff = llply(list_files_ff, read_tsv)
# Combine all measurements for one timepoint... So stupid! Ugliest way ever to
# avoid a nested loop. How the hell can I slice a list in R? Or do an
# apply(list$Mean, mean) on list_data_df etc...
values_df = unlist(list_data_df)
values_ff = unlist(list_data_ff)
intensities_df = values_df[c(grep("Mean", names(values_df)))]
intensities_ff = values_ff[c(grep("Mean", names(values_ff)))]
ratios = intensities_df / intensities_ff
# calculate pH values;  mean and sd
mean_pH = mean(calc_pH(ratios, best_fit))
sd_pH = sd(calc_pH(ratios, best_fit))
df_pH_tmp = data.frame(timepoint=(i-1)*time_resolution, mean_df = mean(intensities_df),
mean_ff = mean(intensities_ff), mean_pH=mean_pH, sd_pH=sd_pH)
df_pH = rbind(df_pH, df_pH_tmp)
}
# Plot
p = ggplot(df_pH, aes(x=timepoint, y=mean_pH))
p = p + geom_line(size=1, colour="red")
p = p + geom_point(size=3)
p = p + geom_errorbar(aes(ymin=mean_pH-sd_pH, ymax=mean_pH+sd_pH), size=1, width=4)
p = p + scale_x_continuous(limits=c(-2, 125), breaks=seq(0, 125, 10))
p = p + scale_y_continuous(breaks=seq(5.8, 7.8, 0.2))
p = p + labs(title=name, x="time [min]", y="pH")
p = p + theme_bw(base_size=24)
p
# Save plot and dataframe
setwd(output_dir)
ggsave(p, file=paste(name, ".pdf", sep=""), width=6, height=5)
write_tsv(df_pH, paste('df_pH_', name, '.txt', sep=''))
write_csv(df_pH, paste('df_pH_', name, '.csv', sep=''))
setwd(working_dir)
rm(list=ls()) # clean up
>>>>>>> no_segmentation
